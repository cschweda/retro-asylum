<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Asylum 3D Maze</title>
    <style>
      body {
        background-color: #222; /* Dark frame around the "monitor" */
        color: #ddd;
        font-family: "Courier New", Courier, monospace;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }

      /* The container for the screen to keep aspect ratio */
      #game-container {
        position: relative;
        border: 20px solid #444;
        border-radius: 10px;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        background: #000;
      }

      /* 
           The Canvas 
           TRS-80 resolution was roughly 128x48 or 160x72 for graphics.
           We render at low res (160x100) and scale up with CSS.
        */
      canvas {
        display: block;
        image-rendering: pixelated; /* Chrome/Edge */
        image-rendering: crisp-edges; /* Firefox */
        width: 800px; /* Display size */
        height: 500px;
        background-color: #fff; /* White background (paper white) */
      }

      .hud {
        margin-top: 10px;
        text-align: center;
        font-size: 14px;
        color: #888;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <!-- Render resolution is set low (160x100) for that retro jagged look -->
      <canvas id="screen" width="160" height="100"></canvas>
    </div>

    <div class="hud">
      <p>ARROWS to Move & Turn | SPACE to Step Forward</p>
    </div>

    <script>
      /**
       * ASYLUM-STYLE RAYCASTER
       *
       * 1. Defines a Map via JSON.
       * 2. Uses a Raycasting algorithm (Wolfenstein 3D style) to determine wall height.
       * 3. Renders vertical black strips on a white background to simulate the TRS-80 look.
       */

      // ==========================================
      // 1. THE MAZE (JSON CONFIGURATION)
      // ==========================================
      // You can replace this object with data loaded from an external .json file.
      // 0 = Empty, 1 = Wall, "S" = Start, "E" = Exit
      const LEVEL_DATA = {
        width: 16,
        height: 16,
        start_facing: "E", // N, S, E, W
        map: [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, "S", 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1],
          [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1],
          [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
          [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
          [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
          [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
          [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
          [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, "E", 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ],
      };

      // ==========================================
      // 2. ENGINE CONSTANTS & STATE
      // ==========================================
      const canvas = document.getElementById("screen");
      const ctx = canvas.getContext("2d", { alpha: false });

      const SCREEN_W = canvas.width;
      const SCREEN_H = canvas.height;

      // Game State
      let posX = 0,
        posY = 0; // Player Position
      let dirX = 0,
        dirY = 0; // Direction Vector
      let planeX = 0,
        planeY = 0; // Camera Plane (determines FOV)

      // Init based on JSON
      function initGame() {
        // Find Start
        for (let y = 0; y < LEVEL_DATA.height; y++) {
          for (let x = 0; x < LEVEL_DATA.width; x++) {
            if (LEVEL_DATA.map[y][x] === "S") {
              posX = x + 0.5; // Center in cell
              posY = y + 0.5;
            }
          }
        }

        // Set Direction
        // TRS-80 Asylum allowed 8 directions, but for simplicity here we do continuous
        // rotation or 90 degree snaps. Let's do standard vectors for smooth rendering
        // but we can snap input if desired.
        setDirection(LEVEL_DATA.start_facing || "N");

        // Initial Draw
        render();
      }

      function setDirection(cardinal) {
        // Basic vectors for N, S, E, W
        // Standard Wolf3D coordinate system: X is Vertical on map, Y is Horizontal?
        // Let's stick to standard math: X horizontal, Y vertical.
        // 0 degrees = East (1, 0).

        let rads = 0;
        if (cardinal === "E") rads = 0;
        if (cardinal === "S") rads = Math.PI / 2;
        if (cardinal === "W") rads = Math.PI;
        if (cardinal === "N") rads = -Math.PI / 2;

        dirX = Math.cos(rads);
        dirY = Math.sin(rads);

        // FOV of 66 degrees is standard, implies plane length of ~0.66
        planeX = -dirY * 0.66;
        planeY = dirX * 0.66;
      }

      // ==========================================
      // 3. RAYCASTING RENDERER
      // ==========================================
      function render() {
        // 1. Clear Screen (White background)
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);

        // 2. Cast rays for every vertical column of pixels
        for (let x = 0; x < SCREEN_W; x++) {
          // Calculate ray position and direction
          let cameraX = (2 * x) / SCREEN_W - 1; // x-coordinate in camera space
          let rayDirX = dirX + planeX * cameraX;
          let rayDirY = dirY + planeY * cameraX;

          // Which box of the map we're in
          let mapX = Math.floor(posX);
          let mapY = Math.floor(posY);

          // Length of ray from current position to next x or y-side
          let sideDistX, sideDistY;

          // Length of ray from one x or y-side to next x or y-side
          // Avoid division by zero
          let deltaDistX = rayDirX === 0 ? 1e30 : Math.abs(1 / rayDirX);
          let deltaDistY = rayDirY === 0 ? 1e30 : Math.abs(1 / rayDirY);
          let perpWallDist;

          // Step direction (+1 or -1)
          let stepX, stepY;
          let hit = 0; // Was there a wall hit?
          let side; // Was a NS or a EW wall hit?

          // Calculate step and initial sideDist
          if (rayDirX < 0) {
            stepX = -1;
            sideDistX = (posX - mapX) * deltaDistX;
          } else {
            stepX = 1;
            sideDistX = (mapX + 1.0 - posX) * deltaDistX;
          }
          if (rayDirY < 0) {
            stepY = -1;
            sideDistY = (posY - mapY) * deltaDistY;
          } else {
            stepY = 1;
            sideDistY = (mapY + 1.0 - posY) * deltaDistY;
          }

          // DDA Algorithm (Digital Differential Analyzer)
          while (hit === 0) {
            // Jump to next map square, OR in x-direction, OR in y-direction
            if (sideDistX < sideDistY) {
              sideDistX += deltaDistX;
              mapX += stepX;
              side = 0;
            } else {
              sideDistY += deltaDistY;
              mapY += stepY;
              side = 1;
            }

            // Check boundaries
            if (
              mapX < 0 ||
              mapY < 0 ||
              mapX >= LEVEL_DATA.width ||
              mapY >= LEVEL_DATA.height
            ) {
              hit = 1; // hit world edge
            } else {
              // Check if wall
              let tile = LEVEL_DATA.map[mapY][mapX];
              if (tile === 1 || tile === "E") hit = 1;
            }
          }

          // Calculate distance projected on camera direction (Euclidean distance gives fisheye)
          if (side === 0) perpWallDist = sideDistX - deltaDistX;
          else perpWallDist = sideDistY - deltaDistY;

          // Calculate height of line to draw on screen
          // In Asylum, walls were quite tall.
          let lineHeight = Math.floor(SCREEN_H / perpWallDist);

          // Calculate lowest and highest pixel to fill in current stripe
          let drawStart = -lineHeight / 2 + SCREEN_H / 2;
          let drawEnd = lineHeight / 2 + SCREEN_H / 2;

          // clamping
          if (drawStart < 0) drawStart = 0;
          if (drawEnd >= SCREEN_H) drawEnd = SCREEN_H - 1;

          // Draw the Wall Strip
          // In Asylum: Walls are Black.
          // Optional: Make side walls slightly gray to visualize corners better?
          // Let's stick to pure B&W for TRS80 feel.

          ctx.fillStyle = "#000000";

          // Trick: To make corners visible in pure monochrome,
          // we can skip drawing the edges or use a dither pattern.
          // Or simpler: Color North/South walls pure black, East/West walls dark dark gray (almost black).
          if (side === 1) ctx.fillStyle = "#222222"; // Very subtle shade diff

          ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
        }

        // Optional: Draw "Exit" Text overlay if near exit
        let mx = Math.floor(posX);
        let my = Math.floor(posY);
        if (LEVEL_DATA.map[my][mx] === "E") {
          ctx.fillStyle = "black";
          ctx.font = "20px monospace";
          ctx.fillText("EXIT FOUND", 40, 50);
        }
      }

      // ==========================================
      // 4. INPUT & MOVEMENT
      // ==========================================
      // Movement speed
      const moveSpeed = 0.15; // squares per tick
      const rotSpeed = 0.1; // radians per tick

      // Key states
      const keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
        Space: false,
      };

      window.addEventListener("keydown", (e) => {
        if (keys.hasOwnProperty(e.code)) {
          keys[e.code] = true;
          e.preventDefault(); // stop scrolling
        }
      });

      window.addEventListener("keyup", (e) => {
        if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
      });

      function gameLoop() {
        let moved = false;

        // Rotation
        if (keys.ArrowLeft) {
          // Rotate camera direction and camera plane
          let oldDirX = dirX;
          dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
          dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
          let oldPlaneX = planeX;
          planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
          planeY =
            oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
          moved = true;
        }
        if (keys.ArrowRight) {
          let oldDirX = dirX;
          dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
          dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
          let oldPlaneX = planeX;
          planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
          planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
          moved = true;
        }

        // Movement
        if (keys.ArrowUp || keys.Space) {
          let newX = posX + dirX * moveSpeed;
          let newY = posY + dirY * moveSpeed;

          // Simple collision detection (treat 1 and "E" as non-walkable for wall logic)
          // We only collide with '1'. We can walk into 'E'.
          let gridX = Math.floor(newX);
          let gridY = Math.floor(posY);
          if (LEVEL_DATA.map[gridY][gridX] !== 1) posX = newX;

          gridX = Math.floor(posX);
          gridY = Math.floor(newY);
          if (LEVEL_DATA.map[gridY][gridX] !== 1) posY = newY;

          moved = true;
        }

        if (keys.ArrowDown) {
          let newX = posX - dirX * moveSpeed;
          let newY = posY - dirY * moveSpeed;

          let gridX = Math.floor(newX);
          let gridY = Math.floor(posY);
          if (LEVEL_DATA.map[gridY][gridX] !== 1) posX = newX;

          gridX = Math.floor(posX);
          gridY = Math.floor(newY);
          if (LEVEL_DATA.map[gridY][gridX] !== 1) posY = newY;

          moved = true;
        }

        if (moved) render();

        requestAnimationFrame(gameLoop);
      }

      // Start
      initGame();
      requestAnimationFrame(gameLoop);
    </script>
  </body>
</html>
